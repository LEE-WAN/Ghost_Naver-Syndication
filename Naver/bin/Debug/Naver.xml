<feed xmlns="http://webmastertool.naver.com">
  <id>http://blog.iwanhae.ga/</id>
  <title>iWan</title>
  <author>
    <name>LEEWANHAE</name>
    <email>puppytrain96@naver.com</email>
  </author>
  <updated>2015-09-26T07:43:01+09:00</updated>
  <link rel="site" href="http://blog.iwanhae.ga" title="iWan" />
  <entry>
    <id>http://blog.iwanhae.ga/evo-850-vs-x110/</id>
    <title>SSD, 850 Evo VS X110 (TLC,MLC 과연 현명한 판단기준인가?)</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-26T01:21:40.263Z</updated>
    <published>2015-09-26T01:21:40.263Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/evo-850-vs-x110/" rel="mobile" />
    <content type="html"><![CDATA[
            <h2 id="">서론</h2>

<blockquote>
  <p>잠깐! 대부분이 알거라 생각되지만 SSD는 정보를 저장하기위해 <strong>셀(CELL)</strong>이라는 최소 저장단위에 전자를 쑤셔넣고 그 전자들이 주변에 흐르는 다른 전자들을 밀어냄으로서 생기는 <strong>전기적 저항</strong>으로 그 셀에 전자가 어느정도 있는지 짐작해서 정보를 읽어냅니다. 여기서 <strong>SLC(SINGLE LEVEL CELL)</strong>는 하나의 <strong>셀(CELL)</strong>에 기준선을 $\frac { 1 }{ 2 }$정도로 잡고 기준치보다 높으면 1 낮으면 0으로 판단하고, <strong>MLC(MULTI LEVEL CELL)</strong>는 하나의 <strong>셀(CELL)</strong>에 기준선을 $\frac { 1 }{ 4 }$마다 놓아 하나의 <strong>셀</strong>에 00,01,10,11 을 판단할수 있게 하는거고, <strong>MLC(MULTI LEVEL CELL)</strong>는 마찬가지 방법으로 000,001,010,011,100,101,110,111 을 판단할수 있게 하는거다.
  <img src="/content/images/2015/09/SSD.png" alt="SSD비교"></p>
</blockquote>

<p><del>보다싶이 네이버에서 120GB대의 SSD에서 1,2위를 다투는 사이다</del></p>

<p>SSD에대해 알아보던중 모든 사람들이 <strong>MLC</strong>란 이유만으로 <strong>X110</strong>을 추천하길레 한번 알아본건데 결과가 꽤나 충격적이더군요.  </p>

<blockquote>
  <p>&nbsp;</p><p>840 EVO 120GB는&nbsp;900테라에 근접을 했는데도 아직 읽기가 가능하지만,,,&nbsp;</p><p><strong><font color="#ff0000">샌디스크 x110 128GB는 455TB 정도부터 벤치에서 읽기 중단 사태</font></strong>가 생기고 있습니다.</p><p>&nbsp;</p><p>최근에 TLC가 MLC의 수명보다 1/10 밖에 안 된다고 하면서, TLC 제품도 까는&nbsp;기사가 올라 왔던데~&nbsp;</p><p><a href="http://cafe.naver.com/ssdsamo/66069" target="_blank">http://cafe.naver.com/ssdsamo/66069</a></p><p><strong><font color="#ff0000"><span style="font-size: 11pt;">낸드&nbsp;자체의 평균 수명 보다는</span><span style="font-size: 11pt;">,,,</span></font></strong></p><p><strong><font color="#ff0000"><span style="font-size: 11pt;">낸드 수율이나 컨트롤러(펌웨어의 낸드 관리) 능력에 따라서</span></font></strong></p><p><strong><font color="#ff0000"><span style="font-size: 11pt;">T</span></font></strong><strong><font color="#ff0000"><span style="font-size: 11pt;">LC 장착 제품이 <span style="font-size: 11pt;">MLC 장착 제품보다</span> 실사용에서 </span><span style="font-size: 11pt;">더 오래 쓸 수도 있다는 것을</span></font></strong></p><p><strong><font color="#ff0000"><span style="font-size: 11pt;">M5S, x110, 840 EVO의&nbsp;수명 테스트에서&nbsp;잘 보여주고 있는 것 같습니다^^</span></font></strong></p>
</blockquote>

<p><em>네이버 카페 SSD사용자의 모임 에서 인용</em></p>

<p>840EVO는 삼성에서 만든 SSD로 TLC에 초반에는 꽤나 호평이었지만 설계상의 미스로 인해 사용기간이 길어질수록 데이터가 파편화, 읽기속도가 느려지는 결함이 있는 SSD입니다..<del>(그리고 이 결함을 수정한게 850EVO고)</del> 그런 SSD조차 800테라는 가볍게 넘어 데이터를 계속 읽고 쓸수가 있지만 왠일인걸 <strong>MLC</strong>인 <strong>X110</strong>이 <strong>그의 절반에도 미치지 못하는 수명</strong>을 자랑하고 있네요.</p>

<p>원인은 간단합니다..</p>

<p>셀 하나에 정보를 8개씩이나 저장할려면 그만큼 세밀한 전압조정과 그에 맞먹는 세밀한 저항 읽어내기가 필요해지고 또 셀 자체가 열화되면서 기록된 데이터가 변형되는 상황까지 고려해줘야 하니깐 <strong>TLC</strong>가 수명이 짧다고 하는건데......</p>

<p>여기서 고려가 안된게 <strong>MLC가 그보단 덜하긴하지만 그래도 여전히 엄청나게 세밀한 조정이 필요하다</strong>라는 것겁니다. 그리고 이 <strong>세밀한 조정</strong>을 하는게 SSD에서 <strong>컨트롤러</strong>라는 것이고요.</p>

<p>TLC는 MLC에비해 확실히 더 세밀한 조정이 필요하지만 <strong>삼성</strong>은 그걸 해낼수 있는 기술력이 있는거고 <strong>샌디스크</strong>는 MLC조차 세밀한 조정에 실패해버리는 처참한 기술력을 가지고 말이 되겠네요.</p>

<p>그리고 여러분들이 한가지 고려해야하는게 회사입장에서 저가형 SSD는 명성이나 뛰어난 기능같은것보다는 <strong>기존 명성을 깎아먹지 않는 선에서 이윤의 폭을 극대화</strong>시키는 방법을 택하는게 정상입니다.. <em>(왜냐하면 저가형은 그냥 용돈벌이용이고 진정 이윤을 내는것은 대부분 기업용 SSD이기 때문)(하나에 1TB넘고 PCI_E같은 포트 가진것들)(회사입장에서는 이쪽명성이 더 중요합니다.)</em></p>

<p>헌데 <strong>샌디스크</strong>는 TLC를 쓰면 이윤은 극대화 되겠지만 자사의 기술력으로는 수명이 너무 짧아져 명성이 깍이겠다 판단, 이윤이 줄더라도 MLC를 써서 수명을 어느정도 보충하고 MLC니깐 더 좋다고 광고하자. 같은 심리로 MLC제품을 만들었을테고</p>

<p><strong>삼성</strong>은 TLC써도 수명은 소비자가 느끼지 못할정도로 많으니깐 괜찮고, 소비자용으로 파는김에 컨트롤러 개발은 덤으로. 같은 심리로 TLC제품들을 내놨을겁니다.</p>

<p>그리고 실제로 삼성의 SSD컨트롤러 기술력은 <strong>외계인 납치, 협박, 고문 전문소</strong>인 <strong>인텔</strong>과 거의 맞먹는정도고 <strong>샌디스크</strong>는 이에관한 명성이 거의 없습니다..</p>

<h2 id="">결론</h2>

<p>좋은 SSD의 판단기준으로 <strong>TLC</strong>냐 <strong>MLC</strong>냐는 전혀 의미가 없습니다. <del>(물론 기업용이나 워크스테이션용은 다릅니다. 이건 일반 PC에 장착되는 SSD를 말하는겁니다.)</del></p>

<p>중요한건 <strong>SSD의 컨트롤러</strong>와 <strong>그걸 최적화하는 기업의 기술력</strong>입니다.</p>

<p>하지만 이를 일반사용자가 알아내기는 힘겠죠.......
<del>(사실 인텔이나 삼성쓰면 대부분 해결되지만요.)</del></p>

<p>가장 최선의 판단법은</p>

<ol>
<li>살려는 모델명을 검색해본다.  </li>
<li>그 모델명과 관련된 큰 논란이 있는지 본다. (840 EVO의 경우 속도저하가 크게 이슈였습니다.)<del>(TLC여서 안된다는 말은 무시해줍시다. 다들 모르고 하는 말이니깐)</del>  </li>
<li>논란이 없으면 그 SSD가 최신제품<em>(나온지 3개월 안)</em>인지 확인해본다.  </li>
<li>최신제품도 아니라면 그 제품을 산다.</li>
</ol>

<p>물론 이 방법으로는 X110과 850EVO중 뭐가 더 좋은지는 구분 못하지만 아셔야 할것이 <strong>하루에 100기가씩 읽기를 12년 해야지 450TB</strong>정도가 나옵니다. 그리고 제 서버는 <strong>24시간 켜두면서</strong> 토렌트나 블로그, 커뮤니티, 깃 같은걸 돌리고도 <strong>하루평균 50기가정도밖에 안읽읍니다</strong>. 결국 삼성께 수명이 더 좋긴했지만 샌디스크도 뭐 어지간해서는 수명의 끝을 보기 힘들다는 소리죠. 그리고 <strong>대부분의 제품은 800TB는 가볍게 뛰어넘는 성능</strong>을 자랑합니다.</p>

<p><strong>10년이면 강산이 변한다</strong>는 말도 변해서 <strong>6개월이면 천지가 변한다</strong>는 말이 성행하는 시대에 20년 넘게 컴퓨터를 쓸일은 거의 없겠죠.</p>

<p>그냥 자기가볼때 디자인이 마음에 들거나 이 회사께 더 마음에 든다 싶으신걸 사시면 됩니다. 물론 벤치마크 성능보시고 사셔도 되고요.</p>
        ]]></content>
    <summary type="text"><![CDATA[서론   잠깐! 대부분이 알거라 생각되지만 SSD는 정보를 저장하기위해 셀(CELL)이라는 최소 저장단위에 전자를 쑤셔넣고 그 전자들이 주변에 흐르는 다른 전자들을 밀어냄으로서 생기는 전기적 저항으로 그 셀에 전자가 어느정도 있는지 짐작해서 정보를 읽어냅니다. 여기서 SLC(SINGLE LEVEL CELL)는 하나의...">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/install-ghost/</id>
    <title>node.js기반 블로그 Ghost 설치하기</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-26T01:16:49.370Z</updated>
    <published>2015-09-26T01:16:49.370Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/install-ghost/" rel="mobile" />
    <content type="html"><![CDATA[
            <h1 id="">서론</h1>

<p>오드로이드나 라즈베리파이로 서버를 돌리는 저에게 있어
사실 이것들은 만족할만한 성능을 내준다고 보기는 힘듭니다.</p>

<p>왜냐하면 워드프레스같은 php기반은 너무 무거워 빠른시간안에 응답하긴 힘들고, 
php를 좀더 가볍게 하기위한 hiphop같은건 ARM을 지원하지 않기때문이죠......</p>

<p>더군다나 워드프레스같은경우 DB구축에 php연결까지 생각해면 
백업&amp;복원이 꽤나 성가십니다.</p>

<p>그래서 이리저리 다른 설치형 프로젝트를 찾다 찾게된것이 Ghost입니다..</p>

<p>Ghost는 node.js를 사용한 설치형 블로그로 <br>
어떤 플랫폼에서도 준수할 성능을 보여주며
블로그 자체도 꽤나 가벼운 편입니다.</p>

<p>또 그뿐아니라 DB나 기타 미디어데이터, 설정데이터 같은것들이
외부에 의존하지않고 자체적으로 해결하기때문에
백업&amp;복원도 폴더만 들고다니면 된다는 엄청난 장점이 있습니다!</p>

<h2 id="">배경지식</h2>

<p>일단 Ghost가 필요로 하는 기본 권장환경은 다음과 같습니다. (2015년 9월 기준)</p>

<blockquote>
  <p>Ghost requires Node.js 0.10.x (not 0.12.x). We recommend Node.js 0.10.40 &amp; npm 2.5.0.</p>
</blockquote>

<p>하지만 실제 확인해본 결과 </p>

<blockquote>
  <p>node.js 0.12.7 &amp; npm 2.14.3 </p>
</blockquote>

<p>에서 정상적인 구동이 됩니다.</p>

<p>여기서 주의해야할 점은 node.js의 가장 상위버전인 4.~버전대는 아직 지원이 안된다는 것입니다.
Ghost자체의 문제라기보단 Ghost가 의존하는 프로그램들 (SQlite3)가 아직 이 버전을 지원하지 않는다고 하네요. <br>
(0.12.~버전대도 초기엔 지원 안했지만 지금은 된다고 합니다.)</p>

<h2 id="nodejsnpm">Node.js&amp;npm 설치</h2>

<p>Node.js는 코드를 실행하는 프로그램 npm은 apt-get과 같은 패키지 관리자 입니다. <br>
Ghost는 DB가 자체적으로 구현되있지 않고 SQlite3를 가져다 쓰기도하고 그 외에도 여러가지 외부프로그램에 의존하기때문에 꼭 필요합니다. <br>
참고로 npm으로 설치되는 프로그램은 모두 Ghost폴더 내에 있으므로 시스템이 지저분해질 걱정은 없습니다.</p>

<p>일단 우분투나 데비안 계열을 사용해 패키지 단위로 설치하려고 한다면</p>

<pre><code>curl --silent --location https://deb.nodesource.com/setup_0.12 | sudo bash -
</code></pre>

<p>를 입력한뒤<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<pre><code>sudo apt-get install nodejs
</code></pre>

<p>해주면 됩니다.</p>

<blockquote>
  <p><em>라즈베리파이의 경우 node.js는 괜찮으나 npm버전에 약간 문제가 있다. <code>npm -v</code>를 했을때 <code>2.~</code>버전보다 낮다면<a href="https://nodejs.org/en/download/">여기</a>에서 ARMv7용을 다운받아두자</em></p>
</blockquote>

<h2 id="ghost">Ghost 다운및 설치</h2>

<pre><code>wget https://ghost.org/zip/ghost-latest.zip
</code></pre>

<p>으로 ghost 파일을 다운로드 한뒤 </p>

<pre><code>sudo unzip -uo ghost.zip -d /var/www/ghost
</code></pre>

<p>해줍니다.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup><sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>
그후</p>

<pre><code>cd /var/www/ghost &amp;&amp; npm install --production
</code></pre>

<p>해주면 <strong>엄청난 시간이 흐른뒤</strong> 알아서 외부 의존성프로그램들을 다운로드한뒤 설치해줍니다.<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>

<blockquote>
  <p><em>라즈베리의 경우 아까 받은 압축을 <code>tar -xvf 파일명</code>으로 해제한뒤 <code>npm</code>대신 <code>/압축해제한 경로/bin/npm install --production</code>으로 해줘야 정상적으로 설치된다. 실행은 node로 되는것이기 때문에 npm버전과 관계없다.</em></p>
</blockquote>

<p>그후</p>

<pre><code>npm start --production
</code></pre>

<p>하면 서버가 실행됩니다.</p>

<p>자신의 컴퓨터에서 <code>127.0.0.1:2368</code>로 들어가면 블로그가 보이고 <code>127.0.0.1:2368/ghost</code>로 들어가면 관리자페이지<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>로 접속가능하니 현재 GUI환경에서 작업중이시라면 한번 들어가보셔도 됩니다.</p>

<p>아직 타인의 컴퓨터에선 이 블로그에 들어올수 없으니 스마트폰같은걸로 접속하진 마시고요.</p>

<h2 id="">외부에서 접속 가능하게 설정하기</h2>

<p>Ghost는 기본프로그램만으로는 아직 외부에서 접속 불가능합니다.<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> <br>
외부에서 접속가능하게 할려면 nginx와의 연계가 필요합니다. </p>

<p>(apache도 되지만 nginx기준으로 설명합니다.)
(참고로 이 기능은 <strong>리버시 프록시</strong>라는 기능입니다. apache환경에서 시도해실분은 이걸 키워드로 찾아보세요)</p>

<p>일단 nginx를 깔아줍니다.</p>

<pre><code>sudo apt-get install nginx
</code></pre>

<p>그후 nginx 설정파일 폴더로 들어가</p>

<pre><code>cd /etc/nginx/sites-available/
</code></pre>

<p><code>ghost.conf</code>라는 파일을 만들어준뒤</p>

<p>파일내용을 다음과 같이 입력합니다.</p>

<pre><code>server {
    listen 80;
    server_name example.com;

    location / {
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   Host      $http_host;
        proxy_pass         http://127.0.0.1:2368;
    }
}
</code></pre>

<p><strong>"example.com"만 자신의 도메인에 맞게 적어줍시다.</strong></p>

<p>그후 <code>sudo service nginx restart</code>해주면 이제 외부에서도 이 블로그를 볼수 있게됩니다.</p>

<h2 id="">컴퓨터 시작시 자동으로 실행하게하기</h2>

<p>컴퓨터 시작시에 자동으로 실행하게 할려면 일단 서비스에 등록이 되야합니다.</p>

<pre><code>sudo curl https://raw.githubusercontent.com/TryGhost/Ghost-Config/master/init.d/ghost \ -o /etc/init.d/ghost
</code></pre>

<p>를 해준뒤 init.d폴더에 들어가</p>

<pre><code>cd /etc/init.d
</code></pre>

<p>ghost파일을 열어보면</p>

<pre><code>#! /bin/sh
### BEGIN INIT INFO
# Provides:          ghost
# Required-Start:    $network $syslog
# Required-Stop:     $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Ghost Blogging Platform
# Description:       Ghost: Just a blogging platform
### END INIT INFO

# Do NOT "set -e"

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC="Ghost"
NAME=ghost
GHOST_ROOT=/var/www/ghost
GHOST_GROUP=ghost
GHOST_USER=ghost
DAEMON=/usr/bin/node
~이하생략~
</code></pre>

<p>가 있습니다.</p>

<p>이중 <code>GHOST_GROUP</code>와<code>GHOST_USER</code>를 자신의 계정이름으로 설정하고<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup><sup id="fnref:9"><a href="#fn:9" rel="footnote">9</a></sup></p>

<p>또 <code>DAEMON</code>도 자신의 nodejs가 있는 주소로 지정해줍시다.<sup id="fnref:10"><a href="#fn:10" rel="footnote">10</a></sup></p>

<p>그리고 이제</p>

<pre><code>sudo chmod 755 /etc/init.d/ghost
</code></pre>

<p>를 실행해 주면</p>

<pre><code>$ service ghost start         //ghost블로그 시작
$ service ghost stop          //ghost블로그 정지
$ service ghost restart       //ghost블로그 재시작
$ service ghost status        //ghost블로그 상태
</code></pre>

<p>명령어들을 사용할수 있게 됩니다!</p>

<p>이제</p>

<pre><code>sudo update-rc.d ghost defaults
sudo update-rc.d ghost enable
</code></pre>

<p>해주면 컴퓨터가 시작될때 자동실행이 됩니다..</p>

<div class="footnotes"><ol><li class="footnote" id="fn:1"><p>위 과정은 node.js 4.~버전이 아닌 0.12버전을 깔도록 해줍니다. <a href="#fnref:1" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:2"><p>debian계열인데 curl이 없다면 <strong>apt-get install curl</strong>해주면 됩니다. <a href="#fnref:2" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:3"><p><strong>/var/www/ghost</strong>에다 압축을 해제하는 이유는 딱히 없지만 앞으로할 모든 설정파일은 이 기준으로 작성되어있으니 자신이 다룰 자신이 있다면 알아서 바꿔줍시다. <a href="#fnref:3" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:4"><p>폴더 없다고 하면 각자 알아서 만들어줍시다. <a href="#fnref:4" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:5"><p><strong>--production</strong>은 <strong>production</strong> 모드로 실행하겠다는 의미이다. 표시 없이 시작하면 <strong>devleop</strong>모드로 자동으로 시작되는며 각 모드는 DB나 설정등이 독립되어있습니다. <strong>npm install --production</strong>에서는 개발자용 도구를 설치하지 않게하는 기능이 있습니다.. <a href="#fnref:5" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:6"><p>관리자 페이지로가서 아이디 비번을 설정해 줘야합니다. <a href="#fnref:6" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:7"><p>베타버전에다가 이것도 개발용으로 배포된거기 때문에 <a href="#fnref:7" title="return to article">↩</a></p></li>

<li class="footnote" id="fn:8"><p><strong>group</strong>을 따로 설정한분은 알아서 바꿔주기. <a href="#fnref:8" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:9"><p>아까 <strong>ghost</strong>설치장소를 임으로 지정한사람은 <strong>GHOST_ROOT</strong>도 그에맞춰 바꾸줍시다. <a href="#fnref:9" title="return to article">↩</a></p></li>
<li class="footnote" id="fn:10"><p><strong>which node</strong>명령어를 실행하면 주소가 나옵니다. <a href="#fnref:10" title="return to article">↩</a></p></li></ol></div>
        ]]></content>
    <summary type="text"><![CDATA[서론 오드로이드나 라즈베리파이로 서버를 돌리는 저에게 있어 사실 이것들은 만족할만한 성능을 내준다고 보기는 힘듭니다. 왜냐하면 워드프레스같은 php기반은 너무 무거워 빠른시간안에 응답하긴 힘들고,  php를 좀더 가볍게 하기위한 hiphop같은건 ARM을 지원하지 않기때문이죠...... 더군다나 워드프레스같은경우 DB구축에 php연결까지 생각해면  백업&amp;amp;복원이 꽤나 성가십니다....">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/preparing-shell-shock/</id>
    <title>쉘쇼크 대비하기</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-24T17:02:07.732Z</updated>
    <published>2015-09-24T17:02:07.732Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/preparing-shell-shock/" rel="mobile" />
    <content type="html"><![CDATA[
            <h2 id="">서론</h2>

<p>작년 이맘때쯤 하트블리드에 이에 쉘쇼크까지 터지면서 보안업계가 출렁였었죠 ㅎㅎ.</p>

<p>그나마 하트블리드는 특정 버전에 제한되있었지만 베쉬셸은......</p>

<p>덕분에 아마 서버업계에서는 "리눅스 서버가 가장 많이 다시깔린날"같은게 아니였을까? 하네요 ㅎㅎ
(업데이트해도 백도어남아있음 큰일이니깐)</p>

<p>뭐 어쨋건 패치도 그때나와서 대부분은 해결 됬겠지만 일부 지원이 끊겨 방치된것들은 아직도 쉘쇼크에 무방비하죠. <del>(대표적으로 저의 오드로이드)(오드로이드는 이 블로그의 서버입니다.)</del>(라즈베리파이는 1,2는 모두 안전합니다.)</p>

<p>그래서 지금 그에대한 글을 써볼려 합니다.</p>

<h2 id="">자신의 상태 확인</h2>

<p>자신이 쉘쇼크에 무방비한지 확인할려면 터미널열고 다음 명령어 입력해보면 됩니다.</p>

<p><code>env x='() { :;}; echo vulnerable' bash -c "echo this is a test"</code></p>

<p><code>vulunerable</code> 나오면.... 당신의 배쉬셸은 간단한 환경변수 놀이에 농락당할수 있습니다. 이제 업데이트를 하셔야 됩니다.</p>

<h2 id="">보안패치</h2>

<p>그냥 <code>apt</code>나 <code>yum</code> 업데이트를 통해 해결되면 매우 좋겠지만 아마 지금도 취약하다면 그냥 업데이트 지원 안하는겁니다.</p>

<p>그럼 다음방안으로 그냥 베쉬셸을 컴파일 합시다.</p>

<p>임의의 폴더에다 <code>a.sh</code>만들어 주시고 파일내용으로 다음을 추가합니다.</p>

<pre><code>TMPDIR=/tmp/bash-src
mkdir $TMPDIR
cd $TMPDIR
#소스 원본 다운로드
wget http://ftp.gnu.org/gnu/bash/bash-4.3.tar.gz
#그에대한 패치도 모두 다운로드
for i in $(seq -f "%03g" 1 999); do 
  wget http://ftp.gnu.org/gnu/bash/bash-4.3-patches/bash43-$i
  if [[ $? -ne "0" ]]; then
    MAX=$(expr $i - 1)
    break;
  fi
done
tar zxf bash-4.3.tar.gz 
cd bash-4.3
#패치 적용
for i in $(seq -f "%03g" 1 $MAX);do
  echo apply patch bash43-$i
  patch -p0 &lt; ../bash43-$i
done
#컴파일 밑 적용
./configure &amp;&amp; make
sudo make install
cd ../..
rm -r $TMPDIR
</code></pre>

<p>이제 실행권한을 주시고 (<code>chmod +x a.sh</code>) 루트권한으로 실행시키면 됩니다.</p>

<p>그럼 알아서 최신버전 다운받아서 컴파일한뒤 설치됩니다.</p>

<p>그후 <code>bash -version</code>이 <code>4.3.42(1)</code>이상을 가리키면 잘 해결된겁니다.</p>

<h2 id="">뒷이야기</h2>

<p>지금와서 이 보안패치는 의미가 있냐? 싶은분들도 많겠지만 의외로 의미가 있는게 개인용 NAS만든다고 Xpenology같은 해킹된 운영체제 깔아놓고 업데이트 안하거나 안나오는 경우가 많습니다. 그리고 이런건 루트권한 탈취된뒤 프록시서버로 활용해 해킹을 가하거나 좀비로 만들어 스팸을 뿌리는일에 가담되는일이 일상다반사라고 하네요.</p>

<p>이는 저도 겪어봤는데요, <del>비록 쉘쇼크가 아닌 ID, PW를 기본으로 맞춰뒀다 발생한 일이지만</del> 훗날 어지간한 사이트의 블랙리스트에 제 ip주소가 있게된걸 깨닫게되고 후회하며<del>(우분투 포럼이랑 오픈수세 포럼에서 BAN당했네요....공유기 교체하여 ip주소 새로 할당받아서 괜찮지만요)</del>  요즘은 보안을 철저하게 관리하고 있습니다. ㅎㅎ</p>
        ]]></content>
    <summary type="text"><![CDATA[서론 작년 이맘때쯤 하트블리드에 이에 쉘쇼크까지 터지면서 보안업계가 출렁였었죠 ㅎㅎ. 그나마 하트블리드는 특정 버전에 제한되있었지만 베쉬셸은...... 덕분에 아마 서버업계에서는 &quot;리눅스 서버가 가장 많이 다시깔린날&quot;같은게 아니였을까? 하네요 ㅎㅎ (업데이트해도 백도어남아있음 큰일이니깐) 뭐 어쨋건 패치도 그때나와서 대부분은 해결 됬겠지만 일부 지원이...">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/csharp-gpgpu/</id>
    <title>C#에서 GPGPU를 사용할만한 방법들</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-24T14:23:02.076Z</updated>
    <published>2015-09-24T14:23:02.076Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/csharp-gpgpu/" rel="mobile" />
    <content type="html"><![CDATA[
            <h2 id="">서론</h2>

<p>C#은 개인적으로 쓰기 참 편한언어이다.</p>

<p>편견일지는 몰라도 C++처럼 일일히 선언, 초기화, 메모리관리, 헤더파일관리 등을 안해도 알아서 처리하고</p>

<p>Java보다는 보기가 편하며</p>

<p>Visual Studio랑 InteliSense라는 엄청난 IDE도 존재한다.</p>

<p>그리고 .Net 4.5에 들어서면서 <code>Parallel</code>클래스가 생기고 심지어 스레드 관리도 할필요없이 멀티코어를 모두 사용가능한 프로그램을 만들수 있게됬다.</p>

<p>그럼에도 GPGPU의 영역은 아직 C#이 다다르진 못한것 같다.</p>

<p>뭐 그도 그럴게 <del>(아직 모두 알아본건 아니지만)</del> 대표적으로 GPGPU를 통해 할수 있는것이 <strong>행렬의 덧셈</strong>과 <strong>행렬의 곱셈</strong>밖에 없기 때문이다.</p>

<p>솔직히 기계학습이나 영상처리면에선 이런기능이 꽤나 유용하지만 일반적인 프로그래머가 이런류를 다룰일은 거의 없을것이다. 그리고 다루게 된다면 다들 <strong>파이썬</strong>을 쓰는게 훨씬 간편하다는걸 잘 알고있을테니 말이다.</p>

<p>그래도 언제나 <del>(적더라도)</del> 수요는 있는법</p>

<p>지금부터 <strong>C#</strong>에서 <strong>GPGPU</strong>를 사용하기위해 찾아본 몇 안되는 방법을 소개하겠다.</p>

<h2 id="">본론</h2>

<ul>
<li><p><a href="https://msdn.microsoft.com/ko-kr/library/hh265136.aspx">C++ AMP</a>를 사용해 <a href="http://blogs.msdn.com/b/pfxteam/archive/2011/09/21/10214538.aspx">C#에서 마샬링</a> 하기.</p>

<p>이 방법은 마이크로소프트에서 제공하는 <code>C++ AMP</code>를 사용해 GPGPU관련 코딩을 마친뒤 C#에서 마샬링해 함수형태로 GPGPU를 활용가능하다.</p>

<ul><li><p>장점 : 윈도우PC에서는 대부분 사용가능하다. DirectX11을 사용해서 연산을 하기때문이다. 그래픽카드도 가리지 않고 잘되며 코딩 난이도도 꽤 쉬운편이다. C++그냥 조금만해도 이용 가능한정도.</p></li>
<li><p>단점 : 윈도에서만 된다. 리눅스에선 못한다. 너무 기본만 구현되 있어서 다 자기가 구현해야한다.</p></li></ul></li>
<li><p><a href="http://devblogs.nvidia.com/parallelforall/accelerate-net-applications-alea-gpu/">Alea GPU</a>이용하기</p>

<p>이 방법은 Nvidia에서 제공하는 CUDA를 C#에서 쓰기위해 만들어진 <code>Alea GPU</code>를 황용하는것이다.</p>

<ul><li>장점 : C#에서 꽤 잘돌아가고, CrossPlatform이 기본모토라서 윈도뿐 아니라 Mac이나 Linux에서도 잘돌아간다. 코딩난이도도 쉬운편이고 F#을 지원해 함수형으로도 사용가능하다. 거기다 디버깅도 잘된다는거 같다.</li>
<li>단점 : CUDA기반이기 때문에 Nvidia에서 CUDA지원 그래픽카드에서만 돌아간다. 라데온이나 내장그래픽 활용은 못한다. 대부분의 노트북이 <del>(인텔이 잘만들어서)</del>내장그래픽화되가는걸 생각하면 단점이 될수도 있다.</li></ul></li>
<li><p>F#에서 짜고 C#에서 쓰기</p>

<p><code>F#</code>은 다른 언어들과는 다르게 하스켈과 같은 함수지향언어이다. 함수지향인만큼 병렬화에 큰 강점을 가져 GPGPU라이브러리가 꽤 있다. 대표적으로 <a href="http://devblogs.nvidia.com/parallelforall/accelerate-net-applications-alea-gpu/">Alea GPU</a> ,<a href="http://www.statfactory.co.uk/">StatFactory</a>, <a href="https://github.com/FSCL/FSCL.Compiler">FSCL</a>(OpenCL을 F#용으로 포팅한것이다.), <a href="https://github.com/nessos/GpuLinq/">GpuLinq</a>(이것도 OpenCL) 등이 있고 이걸 DLL로 만들어 C#에서 가져다 쓰면 된다.</p>

<ul><li>장점 : 라이브러리 존재도 많고 선택지도 다양하며 자기 취양대로 가져다쓸수 있으며 함수지향언어기때문에 병렬화가 쉽다.</li>
<li>단점 : 함수지향언어기에 병렬화가 쉬울지라도 그 개념자체에 익숙해지는데 시간이 걸린다.</li></ul></li>
<li><p>CUDAfy</p>

<p><a href="https://cudafy.codeplex.com/">CUDAfy</a>는 한번 작성하면 OpenCL과 CUDA를 모두 쓸수 있다.</p>

<ul><li>장점 : 한번 작성으로 CUDA랑 OpenCL를 한번에 쓸수있는 편리함</li>
<li>단점 : 커뮤니티가 작고 아직 초기버전이라 버그가 많다. 리눅스는 쓸수 있도록 한다면서 2015년 9월기준으로 아직 제대로 지원하는것 같지는 않다. 조금더 성장하면 꽤 유용하지 않을까? 기대되는 프로젝트이다.</li></ul></li>
<li><p>C#에서 OpenCL쓰기</p>

<p>OpenCL은 지원되는 디바이스도 많고(인텔 내장그래픽에서 ARM프로세서까지) 꽤나 로우레벨을 다루는 만큼 자기 취향대로 코딩이 쉽지만 그게 역으로 작용해 그만큼 코딩이 어렵다. C++에서 컴파일하고 C#에서 마샬링 해야한다.</p>

<ul><li>장점 : 모든걸 자기가 직접 하는만큼 가장 효율적이고 가장 빠른속도를 자랑한다. 이걸 할줄안다면 모바일용 GPGPU도 손쉽게 만들수 있을지도 모른다.</li>
<li>단점 : 그걸 모두 상회할정도로 복잡하고 어려우며 이걸 공부하게될 시간에 다른 방법을 써 코딩하는게 더 효율적이다.</li></ul></li>
<li><p>그냥 내제되있는 라이브러리 쓰기</p>

<p>자신이 만들려는 프로그램목적에 따라 라이브러리를 찾아가다보면 GPGPU가 덤으로 껴있는경우가 종종있다. 예를들면 OpenCVSharp같은경우처럼 특정 알고리즘에 한해 알아서 GPGPU를 돌려주는것 같은것 말이다. 자주 존재하는경우는 아니지만 일단 찾아보자. 이거쓰는게 훨씬 편한경우가 많다. </p></li>
</ul>

<h2 id="">결론</h2>

<p>C#도 나름 GPGPU를 쓰기위한 방법이 존재한다. 그리고 대부분은 C++을 쓰는것보다 쉽다. 하지만 그래도 여전히 파이썬보다는 어렵다. 상용프로그램만드는정도로서는 추천하지만 단순 연구용혹은 논문작성용이라면 파이썬을 쓰는게 속편할 것이다.</p>
        ]]></content>
    <summary type="text"><![CDATA[서론 C#은 개인적으로 쓰기 참 편한언어이다. 편견일지는 몰라도 C++처럼 일일히 선언, 초기화, 메모리관리, 헤더파일관리 등을 안해도 알아서 처리하고 Java보다는 보기가 편하며 Visual Studio랑 InteliSense라는 엄청난 IDE도 존재한다. 그리고 .Net 4.5에 들어서면서 Parallel클래스가 생기고 심지어 스레드 관리도 할필요없이...">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/free-fall-with-air-resistance/</id>
    <title>공기저항을 고려한 자유낙하</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-23T06:09:48.819Z</updated>
    <published>2015-09-23T06:09:48.819Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/free-fall-with-air-resistance/" rel="mobile" />
    <content type="html"><![CDATA[
            <pre><code>k는 현재의 공기저항 상수
s는 거리
v는 속도
a는 가속도
F는 힘
g는 중력가속도
</code></pre>

<p>공기저항은 속도 제곱에 비례하다는 가정하에 다음과 같은 결과가 나온다.</p>

<p>$$F\quad =\quad ma\quad =\quad mg-k{ v }_{  }^{ 2 }$$</p>

<p>$$a\quad =\quad \frac { mg\quad -\quad k{ v }^{ 2 } }{ m } \quad =\quad g-\frac { k{ v }^{ 2 } }{ m } \quad =\frac { dv }{ dt } $$</p>

<p>$$dv\quad =\quad (g-\frac { kv }{ m } )dt$$</p>

<p>$$\int { \frac { 1 }{ g-\frac { k{ v }^{ 2 } }{ m }  } dv } \quad =\int { dt } $$</p>

<p>$$\sqrt { \frac { m }{ gk }  } \tanh ^{ -1 }{ (\frac { v\sqrt { k }  }{ \sqrt { gk }  } ) } \quad =\quad t$$</p>

<p>$$v\quad =\quad \sqrt { \frac { gm }{ k }  } tanh(\frac { t\sqrt { gk }  }{ \sqrt { m }  } )$$</p>

<p>$$s\quad =\quad \int { v\quad dt } \quad =\quad \int { \sqrt { \frac { gm }{ k }  } tanh(\frac { t\sqrt { gk }  }{ \sqrt { m }  } ) } dt\quad =\quad \frac { m }{ k } log(cosh(t\sqrt { \frac { gk }{ m }  } ))$$</p>

<p><img src="/content/images/2015/09/-C0--EA-C0-FB-BA-D0_-_-B0-ED-BE-E7-C0--D4_-BC-F6-BD-C4.png" alt="proofofconcept"></p>

<p>이 식은 위 데이터차트와 같이 높이가 낮은부분에 한해서 매우 정확하다.</p>

<p>하지만 고도가 높아질수록 공기밀도에 변화가 생겨 위에서 k로 잡은 상수가 변수가 되버리고</p>

<p>이는 곧 오차로 나타나 버린다.</p>

<p>-위 수식은 LaTeX로 작성됨-</p>

<p>-그전에 LaTeX를 쓰기위해 이 수식을 유도함-</p>
        ]]></content>
    <summary type="text"><![CDATA[k는 현재의 공기저항 상수 s는 거리 v는 속도 a는 가속도 F는 힘 g는 중력가속도 공기저항은 속도 제곱에 비례하다는 가정하에 다음과 같은 결과가 나온다. $F\quad =\quad ma\quad =\quad mg-k{ v }_{  }^{ 2 }$ $a\quad =\quad \frac { mg\quad -\quad...">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/char_to_wchar_t_unicode/</id>
    <title>(C++)Unicode Char배열을 wchar_t에다가 넣기</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-23T05:55:44.902Z</updated>
    <published>2015-09-23T05:55:44.902Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/char_to_wchar_t_unicode/" rel="mobile" />
    <content type="html"><![CDATA[
            <p>그냥 적당한 XML라이브러리 받아와서
XML로 통신하는게 깔끔하고 편하지만 그래도 가끔 그걸 못쓸때 TCP로 통신한다던가 C#이랑 마샬링같은걸 하면서 유니코드로 문자열 주고받기는 참 어렵다...... </p>

<p>몇몇 상황에서만 적용되는 꼼수이긴 하지만 다음과 같은 방법으로 해결도 가능하다.</p>

<p><code>char* buff = 뭔가 유니코드틱한 문자당 2바이트 이상의 크기를 가진 데이터들이 있는 배열;</code></p>

<p><code>const wchar_t *wc = (const wchar_t*)buff;</code></p>

<p>원리는 간단하다.</p>

<p><mark>wchar</mark><em>(wide char의 약자이다.)</em>
는 char랑 다르게 하나당 2바이트이상의 공간을 가지고 유니코드 형식의 문자열을 표시해준다.</p>

<p>char배열에 저장되 있는 바이트코드를 wchar가 가르키게 하는것이다.</p>

<p>단 이 방법은 모든 플랫폼에서 통용되지는 않는다.</p>

<blockquote>
  <p>5.2.1.2 Multibyte characters</p>
  
  <ol>
  <li>The source character set may contain multibyte characters, used to represent members of
  the extended character set. The execution character set may also contain multibyte <br>
  characters, <mark>which need not have the same encoding as for the source character set</mark>. For <br>
  both character sets, the following shall hold:  </li>
  </ol>
</blockquote>

<h6 id="tt">~중략~</h6>

<blockquote>
  <ol>
  <li>18 Environment §5.2.1.2
  WG14/N1256 Committee Draft — Septermber 7, 2007 ISO/IEC 9899:TC3 <br>
  —<mark>A multibyte character set may have a state-dependent encoding</mark>, wherein each
  sequence of multibyte characters begins in an initial shift state and enters other <br>
  locale-specific shift states when specific multibyte characters are encountered in the <br>
  sequence.</li>
  </ol>
</blockquote>

<p>위 내용은 C99에서 발췌한 내용인데
보다싶이 whar_t에 대한 인코딩은 명확히 규정된게 아니다.</p>

<p>일단 <strong>Microsoft C/C++ compiler</strong>나 <strong>GCC</strong>의 경우 각각 유니코드랑 UTF-32를 사용해서 위 방법이 통용되니 이 두가지 컴파일러에 한해서는 꼼수로 써먹을수 있다.</p>
        ]]></content>
    <summary type="text"><![CDATA[그냥 적당한 XML라이브러리 받아와서 XML로 통신하는게 깔끔하고 편하지만 그래도 가끔 그걸 못쓸때 TCP로 통신한다던가 C#이랑 마샬링같은걸 하면서 유니코드로 문자열 주고받기는 참 어렵다......  몇몇 상황에서만 적용되는 꼼수이긴 하지만 다음과 같은 방법으로 해결도 가능하다. char* buff = 뭔가 유니코드틱한 문자당 2바이트 이상의...">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/entropy_encoding/</id>
    <title>엔트로피 인코딩 (엔트로피 부호화)</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-22T13:30:02.028Z</updated>
    <published>2015-09-22T13:30:02.028Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/entropy_encoding/" rel="mobile" />
    <content type="html"><![CDATA[
            <p>무손실 압축같은 분야에서 애용되는 기법으로</p>

<p>여기서 엔트로피(entropy)는</p>

<pre><code>&lt;통신&gt; 정보량의 기대치를 이르는 말. [비슷한 말] 평균 정보량.
</code></pre>

<p>이라는 의미로 사용된다.</p>

<p>말그대로 기대되는 정보량에대해 부호화(encoding)을 한다는것이다.</p>

<p>예를들면</p>

<p><code>10001010110101001111010100000</code> 
같은걸 </p>

<p><code>1(0, 3개)(10,2개)1(10,2개).....(0,5개)</code>
와 같이 부호화 해준다는 거다.</p>

<p>대표적 엔트로피 인코딩 기법으론 <code>허프만 부호화</code>, <code>범위 부호화</code>와 <code>산술 부호화</code>, <code>런 렝스 코딩</code> 등이 있다.</p>
        ]]></content>
    <summary type="text"><![CDATA[무손실 압축같은 분야에서 애용되는 기법으로 여기서 엔트로피(entropy)는 &amp;lt;통신&amp;gt; 정보량의 기대치를 이르는 말. [비슷한 말] 평균 정보량. 이라는 의미로 사용된다. 말그대로 기대되는 정보량에대해 부호화(encoding)을 한다는것이다. 예를들면 10001010110101001111010100000  같은걸  1(0, 3개)(10,2개)1(10,...">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/rasp-odroid/</id>
    <title>라즈베리파이&amp;오드로이드</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-20T16:13:00.810Z</updated>
    <published>2015-09-20T16:13:00.810Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/rasp-odroid/" rel="mobile" />
    <content type="html"><![CDATA[
            <p>x86환경에서야 뭐든 알아서 완벽하게 되지만 <br>
ARM의경우 사정이 조금 다르다.</p>

<p>이 글은 그런 ARM을 위한 사소한 팁들이 적혀진다.</p>

<p>(발견할때마다 업데이트가 된다.)</p>

<h1 id="nodejs">Node.JS</h1>

<p>node.js는 arm계열을 정식적으로 지원하는 프로그램이지만 <br>
오드로이드의 경우 컴파일하고 <code>make install</code>하면 <code>npm</code>에서 <code>세그멘테이션 오류(core dumped)</code>와 같은 오류가 생긴다. 알려진 원인에 의하면 node의 <code>snapshot</code>기능이 arm에서 제대로 지원이 안된다는 모양이다.</p>

<p>해결법은 <code>./configure</code>할때 <code>./configure --without-snapshot</code>해주면 된다.</p>
        ]]></content>
    <summary type="text"><![CDATA[x86환경에서야 뭐든 알아서 완벽하게 되지만  ARM의경우 사정이 조금 다르다. 이 글은 그런 ARM을 위한 사소한 팁들이 적혀진다. (발견할때마다 업데이트가 된다.) Node.JS node.js는 arm계열을 정식적으로 지원하는 프로그램이지만  오드로이드의 경우 컴파일하고 make install하면 npm에서 세그멘테이션 오류(core dumped)와 같은...">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/locale_setting/</id>
    <title>우분투 서버 한글화 절차</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-20T13:30:20.660Z</updated>
    <published>2015-09-20T13:30:20.660Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/locale_setting/" rel="mobile" />
    <content type="html"><![CDATA[
            <pre><code>apt-get install language-pack-ko
locale-gen ko_KR.UTF-8
LANG=ko_KR.URF-8
LANGUAGE=ko_KR:ko:en_GB:en
</code></pre>

<p>그후 <code>/etc/default/locale</code> 에다가</p>

<pre><code>LANG=ko_KR.UTF-8
</code></pre>

<p>추가</p>

<pre><code>locale
</code></pre>

<p>로 제대로됬는지 확인</p>

<p>14.04버전 기준이다. <br>
Debian계열에선 전부 작동한다.</p>
        ]]></content>
    <summary type="text"><![CDATA[apt-get install language-pack-ko locale-gen ko_KR.UTF-8 LANG=ko_KR.URF-8 LANGUAGE=ko_KR:ko:en_GB:en 그후 /etc/default/locale 에다가 LANG=ko_KR.UTF-8 추가 locale 로 제대로됬는지 확인 14.04버전 기준이다.  Debian계열에선 전부 작동한다....">]]></summary>
  </entry>
  <entry>
    <id>http://blog.iwanhae.ga/hi/</id>
    <title>Hi</title>
    <author>
      <name>LEE WAN HAE</name>
    </author>
    <updated>2015-09-19T18:26:13.857Z</updated>
    <published>2015-09-19T18:26:13.857Z</published>
    <link title="Main Page" href="http://blog.iwanhae.ga" rel="via" />
    <link href="http://blog.iwanhae.ga/hi/" rel="mobile" />
    <content type="html"><![CDATA[
            <p>Success in installing the Ghost Blog, which run by node.js</p>
        ]]></content>
    <summary type="text"><![CDATA[Success in installing the Ghost Blog, which run by node.js...">]]></summary>
  </entry>
  <deleted-entry when="2015-09-26T07:43:01+09:00" ref="http://blog.iwanhae.ga/welcome-to-ghost/" />
</feed>